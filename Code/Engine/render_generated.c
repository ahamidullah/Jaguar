// This file was auto-generated by material_compiler.c.

#include "GPU.h"

void Create_Material_Pipelines(Render_API_Context *context, GPU_Shader shaders[GPU_SHADER_COUNT], GPU_Render_Pass scene_render_pass, GPU_Pipeline *pipelines) {
	{
		GPU_Framebuffer_Attachment_Color_Blend_Description colorBlendDescription = {
				.enable_blend = true,
				.source_color_blend_factor = GPU_BLEND_FACTOR_SRC_ALPHA,
				.destination_color_blend_factor = GPU_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
				//.srcColorBlendFactor = VK_BLEND_FACTOR_ONE,
				//.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO,
				.color_blend_operation = GPU_BLEND_OP_ADD ,
				.source_alpha_blend_factor = GPU_BLEND_FACTOR_ONE,
				.destination_alpha_blend_factor = GPU_BLEND_FACTOR_ZERO,
				.alpha_blend_operation = (GPU_Blend_Operation)VK_BLEND_OP_ADD,
				.color_write_mask = (GPU_Color_Component_Flags)(GPU_COLOR_COMPONENT_RED | GPU_COLOR_COMPONENT_GREEN | GPU_COLOR_COMPONENT_BLUE | GPU_COLOR_COMPONENT_ALPHA),
		};
		GPU_Pipeline_Vertex_Input_Attribute_Description vertexInputAttributeDescriptions[] = {
			{
				.format = GPU_FORMAT_R32G32B32_SFLOAT,
				.binding = GPU_VERTEX_BUFFER_BIND_ID,
				.location = 0,
				.offset = 0,
			},
		};
		GPU_Pipeline_Vertex_Input_Binding_Description vertexInputBindingDescriptions[] = {
			{
				.binding = GPU_VERTEX_BUFFER_BIND_ID,
				.stride = sizeof(V3),
				.input_rate = GPU_VERTEX_INPUT_RATE_VERTEX,
			},
		};
		GPU_Dynamic_Pipeline_State dynamicStates[] = {
			GPU_DYNAMIC_PIPELINE_STATE_VIEWPORT,
			GPU_DYNAMIC_PIPELINE_STATE_SCISSOR,
		};
		GPU_Pipeline_Description pipeline_description = {
			.descriptor_set_layout_count = RUSTED_IRON_DESCRIPTOR_SET_LAYOUT_COUNT,
			.descriptor_set_layouts = &context->descriptor_set_layouts[RUSTED_IRON_VERTEX_BIND_PER_MATERIAL_UPDATE_DELAYED_DESCRIPTOR_SET],
			.push_constant_count = 0,
			.push_constant_descriptions = NULL,
			.topology = GPU_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
			.viewport_width = (f32)windowWidth,
			.viewport_height = (f32)windowHeight,
			.scissor_width = windowWidth,
			.scissor_height = windowHeight,
			.depth_compare_operation = (GPU_Compare_Operation)VK_COMPARE_OP_LESS,
			.framebuffer_attachment_color_blend_count = 1,
			.framebuffer_attachment_color_blend_descriptions = &colorBlendDescription,
			.vertex_input_attribute_count = 1,
			.vertex_input_attribute_descriptions = vertexInputAttributeDescriptions,
			.vertex_input_binding_count = 1,
			.vertex_input_binding_descriptions = vertexInputBindingDescriptions,
			.dynamic_state_count = 2,
			.dynamic_states = dynamicStates,
			.shader = shaders[RUSTED_IRON_SHADER],
			.render_pass = scene_render_pass,
			.enable_depth_bias = false,
		};
		pipelines[RUSTED_IRON_SHADER] = Render_API_Create_Pipeline(context, &pipeline_description);
	}
}

GPU_Shader_Descriptor_Sets Create_Descriptor_Sets_For_Shader(Render_Context *context, u32 swapchain_image_count, GPU_Descriptor_Pool descriptor_pool, GPU_Shader_ID shader_id) {
	GPU_Shader_Descriptor_Sets sets = {};
	switch (shader_id) {
	case RUSTED_IRON_SHADER: {
		s32 set_count = 1 * swapchain_image_count + 1;
		sets.sets = &context->descriptor_sets[context->descriptor_set_count];
		sets.set_count = set_count;
		context->descriptor_set_count += set_count;
		Render_API_Create_Descriptor_Sets(&context->api_context, descriptor_pool, (GPU_Descriptor_Set_ID)0, set_count, sets.sets);
		sets.buffer = Renderer::CreateGPUBuffer(sizeof(M4) * swapchain_image_count + 0x100 * swapchain_image_count, (GPU_Buffer_Usage_Flags)(GPU_UNIFORM_BUFFER | GPU_TRANSFER_DESTINATION_BUFFER));
	} break;
	default: {
		Abort("invalid shader id");
	} break;
	}
	return sets;
}

void Update_Descriptors(Render_Context *context, GPU_Fence fence, s32 swapchain_image_index, GPU_Shader_Descriptor_Sets *sets, s32 update_count, GPU_Descriptor_Update_Info *update_infos) {
	void *staging_memory;
	GPU_Buffer staging_buffer = Renderer::CreateGPUStagingBuffer(sizeof(M4), &staging_memory);
	CopyMemory(&update_infos[0].data.m4, staging_memory, sizeof(M4));
	GPU_Command_Buffer command_buffer = Render_API_Create_Command_Buffer(context->thread_local_contexts[threadIndex].command_pools[context->currentFrame]);
	Render_API_Record_Copy_Buffer_Command(command_buffer, sizeof(M4), staging_buffer, sets->buffer, 0, 0x100 * swapchain_image_index);
	Render_API_End_Command_Buffer(command_buffer);
	Render_API_Submit_Command_Buffers(1, &command_buffer, GPU_GRAPHICS_COMMAND_QUEUE, fence);
	Render_API_Update_Descriptor_Sets(&context->api_context, swapchain_image_index, sets->sets[0], sets->buffer);
}

